<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.quant documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b8-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-elim"><div class="inner"><span>ex-in-elim</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-elim-thm"><div class="inner"><span>ex-in-elim-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-intro"><div class="inner"><span>ex-in-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-intro-thm"><div class="inner"><span>ex-in-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-exists-in"><div class="inner"><span>exists-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-forall-in"><div class="inner"><span>forall-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in"><div class="inner"><span>single-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in-prop"><div class="inner"><span>single-in-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element"><div class="inner"><span>the-element</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-ax"><div class="inner"><span>the-element-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-lemma"><div class="inner"><span>the-element-lemma</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-lemma-thm"><div class="inner"><span>the-element-lemma-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-prop"><div class="inner"><span>the-element-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-prop-ax"><div class="inner"><span>the-element-prop-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-unique-in"><div class="inner"><span>unique-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-unique-in-prop"><div class="inner"><span>unique-in-prop</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.quant</h1><div class="doc"><div class="markdown"><p>Quantifiers over sets (rather than types), with most definitions specialized from <a href="null">latte-prelude.quant</a>.</p></div></div><div class="public anchor" id="var-ex-in-elim"><h3>ex-in-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The elimination rule for the <code>exists-in</code> existential quantifier over a set <code>s</code> (of elements of type <code>T</code>). A typical proof instance is of the form <code>((ex-elim s P A) ex-proof A-proof)</code> with <code>ex-term</code> a proof of <code>(exists-in [x s] (P x))</code> and <code>A-proof</code> a proof of <code>(==&gt; (forall-in [x s] (==&gt; (P x) A)))</code>. See <a href="null">ex-in-elem-thm</a>.</p></div></div></div><div class="public anchor" id="var-ex-in-elim-thm"><h3>ex-in-elim-thm</h3><div class="usage"><code>(ex-in-elim-thm [T :type] [s (set T)] [P (==&gt; T :type)] [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (exists-in [x s] (P x)) (forall-in [y s] (==&gt; (P y) A)) A)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for <code>exists-in</code> existentials, a simple variant of <a href="null">latte-prelude.quant/ex-elim-thm</a>.</p></div></div></div><div class="public anchor" id="var-ex-in-intro"><h3>ex-in-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The introduction rule for the <code>exists-in</code> quantifier. Given a set <code>s</code>, a property <code>P</code> of the elements of <code>s</code> and <code>x</code> an element </p>
<p>A typical introduction proof is a term <code>((ex-in-intro s P x) sx-proof px-proof)</code> introduces the type <code>(exists-in [y s] (P y))</code> provided that <code>sx-proof</code> is a proof of <code>(elem x s)</code> and <code>px-proof</code> is a proof of <code>(P x)</code>.</p>
<p>See <a href="latte-sets.quant.html#var-ex-in-intro-thm">ex-in-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-ex-in-intro-thm"><h3>ex-in-intro-thm</h3><div class="usage"><code>(ex-in-intro-thm [T :type] [s (set T)] [P (==&gt; T :type)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x s) (P x) (exists-in [y s] (P y)))
</code></pre>
<p><strong>Theorem</strong>: The introduction rule for the <code>exists-in</code> quantifier, cf. <a href="null">latte-prelude.quant/ex-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-exists-in"><h3>exists-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Existential quantification over sets.</p>
<p><code>(exists-in [x s] (P x))</code> is a shortcut for <code>(exists [x (element-type-of s)]
                 (and (elem x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-forall-in"><h3>forall-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Universal quantification over sets.</p>
<p><code>(forall-in [x s] (P x))</code> is a shortcut for <code>(forall [x (element-type-of s)]
                 (==&gt; (elem x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-single-in"><h3>single-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The constraints that “there exists at most one element in set <code>s</code> such that…”, cf. <a href="latte-sets.quant.html#var-single-in-prop">single-in-prop</a>.</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/single</a>.</p></div></div></div><div class="public anchor" id="var-single-in-prop"><h3>single-in-prop</h3><div class="usage"><code>(single-in-prop [T :type] [s (set T)] [P (==&gt; T :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [x s] (forall-in [y s] (==&gt; (P x) (P y) (equal x y))))
</code></pre>
<p><strong>Definition</strong>: The constraints that “there exists at most one element of type <code>T</code> in set <code>s</code> such that…”</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/single-prop</a>.</p></div></div></div><div class="public anchor" id="var-the-element"><h3>the-element</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The unique element descriptor for sets.</p>
<p><code>(the-element s P u)</code> defines the unique element of  set <code>s</code> satisfying the predicate <code>P</code>. This is provided  thanks to the uniqueness proof <code>u</code> (of type <code>(unique-in s P)</code>.</p>
<p>This is the set-theoretic version of the <a href="null">latte-prelude.quant/the</a>.</p></div></div></div><div class="public anchor" id="var-the-element-ax"><h3>the-element-ax</h3><div class="usage"><code>(the-element-ax [T :type] [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>T
</code></pre>
<p><strong>Axiom</strong>: The unique element descriptor axiom.</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/the-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-element-lemma"><h3>the-element-lemma</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The unique element … in <code>s</code> is … unique, cf. <a href="latte-sets.quant.html#var-the-element-lemma-thm">the-element-lemma-thm</a>.</p></div></div></div><div class="public anchor" id="var-the-element-lemma-thm"><h3>the-element-lemma-thm</h3><div class="usage"><code>(the-element-lemma-thm [T :type] [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [y s] (==&gt; (P y) (equal y (the-element s P u))))
</code></pre>
<p><strong>Theorem</strong>: The unique element … in <code>s</code> is … unique, cf <a href="null">latte-prelude.quand/the-lemma-thm</a>.</p></div></div></div><div class="public anchor" id="var-the-element-prop"><h3>the-element-prop</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The property of <code>the-element</code>, from <a href="latte-sets.quant.html#var-the-element-prop-ax">the-element-prop-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-element-prop-ax"><h3>the-element-prop-ax</h3><div class="usage"><code>(the-element-prop-ax [T :type] [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (elem (the-element s P u) s) (P (the-element s P u)))
</code></pre>
<p><strong>Axiom</strong>: The property of the unique element descriptor, cf. <a href="null">latte-prelude.quant/the-prop-ax</a>.</p></div></div></div><div class="public anchor" id="var-unique-in"><h3>unique-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The constraint that “there exists a unique element of type <code>T</code>  in set <code>s</code> such that …”</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/unique</a>.</p></div></div></div><div class="public anchor" id="var-unique-in-prop"><h3>unique-in-prop</h3><div class="usage"><code>(unique-in-prop [T :type] [s (set T)] [P (==&gt; T :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (exists-in [x s] (P x)) (single-in s P))
</code></pre>
<p><strong>Definition</strong>: The constraint that “there exists a unique element of type <code>T</code>  in set <code>s</code> such that …”.</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/unique-prop</a>.</p></div></div></div></div></body></html>