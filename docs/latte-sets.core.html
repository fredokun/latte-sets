<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.core.html#var-elem"><div class="inner"><span>elem</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-elem-def"><div class="inner"><span>elem-def</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-emptyset"><div class="inner"><span>emptyset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-emptyset-prop"><div class="inner"><span>emptyset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-exists-in"><div class="inner"><span>exists-in</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-fetch-set-type"><div class="inner"><span>fetch-set-type</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-forall-in"><div class="inner"><span>forall-in</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-fullset"><div class="inner"><span>fullset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-fullset-intro"><div class="inner"><span>fullset-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset"><div class="inner"><span>psubset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-antirefl"><div class="inner"><span>psubset-antirefl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-antirefl-thm"><div class="inner"><span>psubset-antirefl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-antisym"><div class="inner"><span>psubset-antisym</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-antisym-thm"><div class="inner"><span>psubset-antisym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-def"><div class="inner"><span>psubset-def</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-emptyset"><div class="inner"><span>psubset-emptyset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-emptyset-conv"><div class="inner"><span>psubset-emptyset-conv</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-emptyset-equiv"><div class="inner"><span>psubset-emptyset-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-trans"><div class="inner"><span>psubset-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-psubset-trans-thm"><div class="inner"><span>psubset-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set"><div class="inner"><span>set</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal"><div class="inner"><span>set-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-implies-seteq"><div class="inner"><span>set-equal-implies-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-implies-subset"><div class="inner"><span>set-equal-implies-subset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-prop"><div class="inner"><span>set-equal-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-refl"><div class="inner"><span>set-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-refl-thm"><div class="inner"><span>set-equal-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-seteq"><div class="inner"><span>set-equal-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-sym"><div class="inner"><span>set-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-sym-thm"><div class="inner"><span>set-equal-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-trans"><div class="inner"><span>set-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-trans-thm"><div class="inner"><span>set-equal-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equality"><div class="inner"><span>set-equality</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-of"><div class="inner"><span>set-of</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq"><div class="inner"><span>seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-def"><div class="inner"><span>seteq-def</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-implies-set-equal-ax"><div class="inner"><span>seteq-implies-set-equal-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-refl"><div class="inner"><span>seteq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-refl-thm"><div class="inner"><span>seteq-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-sym"><div class="inner"><span>seteq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-sym-thm"><div class="inner"><span>seteq-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-trans"><div class="inner"><span>seteq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-trans-thm"><div class="inner"><span>seteq-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset"><div class="inner"><span>subset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-def"><div class="inner"><span>subset-def</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-elim-thm"><div class="inner"><span>subset-elim-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-emptyset-lower-bound"><div class="inner"><span>subset-emptyset-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-fullset-upper-bound"><div class="inner"><span>subset-fullset-upper-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-intro"><div class="inner"><span>subset-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-intro-thm"><div class="inner"><span>subset-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-prop"><div class="inner"><span>subset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-refl"><div class="inner"><span>subset-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-refl-thm"><div class="inner"><span>subset-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-trans"><div class="inner"><span>subset-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-trans-thm"><div class="inner"><span>subset-trans-thm</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.core</h1><div class="doc"><div class="markdown"><p>Set-theoretic notions based on the subset  approach of type theory.</p>
<p>The main idea is to consider a typed variant of  a mathematical set as a predicate over a given type.</p>
<p>What is called a <strong>set</strong> will be technically-speaking  a subset of a type, hence a predicate over a given type.  This means that the set theory developed here is <em>typed</em>  and thus quite different than the standard axiomatic set theories (e.g. ZF and ZFC), which are essentially untyped.</p>
<p>But many set-theoretic constructions and results have a natural translation to the typed setting.</p></div></div><div class="public anchor" id="var-elem"><h3>elem</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(elem x s)</code></p>
<p>Object <code>x</code> is member of set <code>s</code>, cf. <a href="latte-sets.core.html#var-elem-def">elem-def</a>.</p></div></div></div><div class="public anchor" id="var-elem-def"><h3>elem-def</h3><div class="usage"><code>(elem-def [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(s x)
</code></pre>
<p><strong>Definition</strong>: Set membership. </p>
<p>Given a type <code>T</code>, a value <code>x</code> of type <code>T</code> and  a set <code>s</code>, then <code>(elem T x s)</code> means that <code>x</code> is an element of set <code>s</code>.  The standard mathematical notation is: <code>x</code>∊<code>s</code> (leaving the type <code>T</code> implicit).</p></div></div></div><div class="public anchor" id="var-emptyset"><h3>emptyset</h3><div class="usage"><code>(emptyset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] p/absurd)
</code></pre>
<p><strong>Definition</strong>: The empty set of a type.</p></div></div></div><div class="public anchor" id="var-emptyset-prop"><h3>emptyset-prop</h3><div class="usage"><code>(emptyset-prop [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (not (elem x (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: The main property of the empty set.</p></div></div></div><div class="public anchor" id="var-exists-in"><h3>exists-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Existential quantification over sets.</p>
<p><code>(exists-in [x T s] (P x))</code> is a shortcut for <code>(exists [x T]
                 (and (elem T x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-fetch-set-type"><h3>fetch-set-type</h3><div class="usage"><code>(fetch-set-type def-env ctx s-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-forall-in"><h3>forall-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Universal quantification over sets.</p>
<p><code>(forall-in [x T s] (P x))</code> is a shortcut for <code>(forall [x T]
                 (==&gt; (elem T x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-fullset"><h3>fullset</h3><div class="usage"><code>(fullset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] p/truth)
</code></pre>
<p><strong>Definition</strong>: The full set of a type (all the inhabitants of the type are element of the full set).</p></div></div></div><div class="public anchor" id="var-fullset-intro"><h3>fullset-intro</h3><div class="usage"><code>(fullset-intro [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (elem x (fullset T)))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for the full set.</p></div></div></div><div class="public anchor" id="var-psubset"><h3>psubset</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubset s1 s2)</code></p>
<p><code>s1</code> is a propre subset of <code>s2</code>, cf. <a href="latte-sets.core.html#var-psubset-def">psubset-def</a>.</p></div></div></div><div class="public anchor" id="var-psubset-antirefl"><h3>psubset-antirefl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubset-antirefl s)</code></p>
<p><code>(psubset-antirefl s)</code> means proper subset relation is antireflexive, cf. <a href="latte-sets.core.html#var-psubset-antirefl-thm">psubset-antirefl-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubset-antirefl-thm"><h3>psubset-antirefl-thm</h3><div class="usage"><code>(psubset-antirefl-thm [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (psubset s s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-antisym"><h3>psubset-antisym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubset-antisym s1 s2)</code></p>
<p><code>(psubset-antisym s1 s2)</code> means proper subset relation is antisymmetric, cf. <a href="latte-sets.core.html#var-psubset-antisym-thm">psubset-antisym-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubset-antisym-thm"><h3>psubset-antisym-thm</h3><div class="usage"><code>(psubset-antisym-thm [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (and (psubset s1 s2) (psubset s2 s1)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-def"><h3>psubset-def</h3><div class="usage"><code>(psubset-def [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset s1 s2) (not (seteq s1 s2)))
</code></pre>
<p><strong>Definition</strong>: The anti-reflexive variant of the subset relation.</p>
<p>The expression <code>(psubset T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, but that the two sets are distinct, i.e. <code>s1</code>⊂<code>s2</code> (or more explicitely <code>s1</code>⊊<code>s2</code>).</p></div></div></div><div class="public anchor" id="var-psubset-emptyset"><h3>psubset-emptyset</h3><div class="usage"><code>(psubset-emptyset [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubset (emptyset T) s) (not (seteq s (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-emptyset-conv"><h3>psubset-emptyset-conv</h3><div class="usage"><code>(psubset-emptyset-conv [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (not (seteq s (emptyset T))) (psubset (emptyset T) s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-emptyset-equiv"><h3>psubset-emptyset-equiv</h3><div class="usage"><code>(psubset-emptyset-equiv [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (psubset (emptyset T) s) (not (seteq s (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-trans"><h3>psubset-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubset-trans s1 s2 s3)</code></p>
<p><code>(psubset-trans s1 s2 s3)</code>. The proper subset relation is transitive, cf. <a href="latte-sets.core.html#var-psubset-trans-thm">psubset-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubset-trans-thm"><h3>psubset-trans-thm</h3><div class="usage"><code>(psubset-trans-thm [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubset s1 s2) (psubset s2 s3) (psubset s1 s3))
</code></pre>
<p><strong>Theorem</strong>: The proper subset relation is transitive.</p></div></div></div><div class="public anchor" id="var-set"><h3>set</h3><div class="usage"><code>(set [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T :type)
</code></pre>
<p><strong>Definition</strong>: The type of sets whose elements are of type <code>T</code>.</p></div></div></div><div class="public anchor" id="var-set-equal"><h3>set-equal</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-equal s1 s2)</code></p>
<p>The <em>Leibniz</em>-style equality for sets, cf. <a href="latte-sets.core.html#var-set-equality">set-equality</a>.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-seteq"><h3>set-equal-implies-seteq</h3><div class="usage"><code>(set-equal-implies-seteq [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (seteq s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Subset-based equality implies <em>Leibniz</em>-style equality on sets.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-subset"><h3>set-equal-implies-subset</h3><div class="usage"><code>(set-equal-implies-subset [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (subset s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Going from <em>Leibniz</em> equality on sets to the subset relation is easy.</p></div></div></div><div class="public anchor" id="var-set-equal-prop"><h3>set-equal-prop</h3><div class="usage"><code>(set-equal-prop [T :type] [s1 (set T)] [s2 (set T)] [P (==&gt; (set T) :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (P s1) (P s2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-set-equal-refl"><h3>set-equal-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-equal-refl s)</code></p>
<p>Reflexivity of set equality, cf. <a href="latte-sets.core.html#var-set-equal-refl-thm">set-equal-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-set-equal-refl-thm"><h3>set-equal-refl-thm</h3><div class="usage"><code>(set-equal-refl-thm [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-equal s s)
</code></pre>
<p><strong>Theorem</strong>: Reflexivity of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-seteq"><h3>set-equal-seteq</h3><div class="usage"><code>(set-equal-seteq [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (seteq s1 s2) (set-equal s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Set equality and subset-based equality (should) coincide (axiomatically).</p></div></div></div><div class="public anchor" id="var-set-equal-sym"><h3>set-equal-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-equal-sym s1 s2)</code></p>
<p>Symmetry of set equality, cf. <a href="latte-sets.core.html#var-set-equal-sym-thm">set-equal-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-set-equal-sym-thm"><h3>set-equal-sym-thm</h3><div class="usage"><code>(set-equal-sym-thm [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (set-equal s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-trans"><h3>set-equal-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-equal-trans s1 s2 s3)</code></p>
<p>Transitivity of set equality, cf. <a href="latte-sets.core.html#var-set-equal-trans-thm">set-equal-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-set-equal-trans-thm"><h3>set-equal-trans-thm</h3><div class="usage"><code>(set-equal-trans-thm [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (set-equal s2 s3) (set-equal s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Transitivity of set equality.</p></div></div></div><div class="public anchor" id="var-set-equality"><h3>set-equality</h3><div class="usage"><code>(set-equality [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (set T) :type)] (&lt;=&gt; (P s1) (P s2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-style equality for sets.</p>
<p>It says that two sets <code>s1</code> and <code>s2</code> are equal iff for any predicate <code>P</code> then <code>(P s1)</code> if and only if <code>(P s2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.core.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-set-of"><h3>set-of</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Definition of a set by comprehension.</p>
<p><code>(set-of [x T] (P x))</code> is the set of all <code>x</code>’s of type <code>T</code> such  that <code>(P x)</code>. This is similar to the notation <code>{x : T | P(x) }</code> in classical mathematics.</p>
<p>Note that it is exactly the same as <code>(lambda [x T] (P x))</code></p></div></div></div><div class="public anchor" id="var-seteq"><h3>seteq</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(seteq s1 s2)</code></p>
<p>Set <code>s1</code> is equal to <code>s2</code>, cf. <a href="latte-sets.core.html#var-seteq-def">seteq-def</a>.</p></div></div></div><div class="public anchor" id="var-seteq-def"><h3>seteq-def</h3><div class="usage"><code>(seteq-def [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset s1 s2) (subset s2 s1))
</code></pre>
<p><strong>Definition</strong>: Set equivalence. This is a natural notion of “equal sets”  based on the subset relation.</p></div></div></div><div class="public anchor" id="var-seteq-implies-set-equal-ax"><h3>seteq-implies-set-equal-ax</h3><div class="usage"><code>(seteq-implies-set-equal-ax [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (set-equal s1 s2))
</code></pre>
<p><strong>Axiom</strong>: Going from subset-based equality to <em>Leibniz</em>-style equality requires this axiom. This is because we cannot lift membership  to an arbitrary predicate.</p></div></div></div><div class="public anchor" id="var-seteq-refl"><h3>seteq-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(seteq-refl s)</code></p>
<p>Set <code>s</code> is equal to itself, cf. <a href="latte-sets.core.html#var-seteq-refl-thm">seteq-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-seteq-refl-thm"><h3>seteq-refl-thm</h3><div class="usage"><code>(seteq-refl-thm [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq s s)
</code></pre>
<p><strong>Theorem</strong>: Set equality is reflexive.</p></div></div></div><div class="public anchor" id="var-seteq-sym"><h3>seteq-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(seteq-sym s1 s2)</code></p>
<p>Set equality is symmetric, cf. <a href="latte-sets.core.html#var-seteq-sym-thm">seteq-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-seteq-sym-thm"><h3>seteq-sym-thm</h3><div class="usage"><code>(seteq-sym-thm [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (seteq s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Set equality is symmetric.</p></div></div></div><div class="public anchor" id="var-seteq-trans"><h3>seteq-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(seteq-trans s1 s2 s3)</code></p>
<p><code>(seteq-trans s1 s2 s3)</code>. Set equality is transitive, cf. <a href="latte-sets.core.html#var-seteq-trans-thm">seteq-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-seteq-trans-thm"><h3>seteq-trans-thm</h3><div class="usage"><code>(seteq-trans-thm [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (seteq s2 s3) (seteq s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Set equality is transitive.</p></div></div></div><div class="public anchor" id="var-subset"><h3>subset</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subset s1 s2)</code></p>
<p><code>(subset s1 s2)</code> mens set <code>s1</code> is a subset of <code>s2</code> i.e. <code>s1</code>⊆<code>s2</code>, cf. <a href="latte-sets.core.html#var-subset-def">subset-def</a>.</p></div></div></div><div class="public anchor" id="var-subset-def"><h3>subset-def</h3><div class="usage"><code>(subset-def [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (==&gt; (elem x s1) (elem x s2)))
</code></pre>
<p><strong>Definition</strong>: The subset relation for type <code>T</code>. The expression <code>(subset-def T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, i.e. <code>s1</code>⊆<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-subset-elim-thm"><h3>subset-elim-thm</h3><div class="usage"><code>(subset-elim-thm [T :type] [s1 (set T)] [s2 (set T)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x s1) (subset s1 s2) (elem x s2))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for subset relation.</p></div></div></div><div class="public anchor" id="var-subset-emptyset-lower-bound"><h3>subset-emptyset-lower-bound</h3><div class="usage"><code>(subset-emptyset-lower-bound [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset (emptyset T) s)
</code></pre>
<p><strong>Theorem</strong>: The emptyset is a subset of every other sets.</p></div></div></div><div class="public anchor" id="var-subset-fullset-upper-bound"><h3>subset-fullset-upper-bound</h3><div class="usage"><code>(subset-fullset-upper-bound [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset s (fullset T))
</code></pre>
<p><strong>Theorem</strong>: The fullset is a superset of every other sets.</p></div></div></div><div class="public anchor" id="var-subset-intro"><h3>subset-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subset-intro s1 s2)</code></p>
<p>Introduction rule for subset, cf. <a href="latte-sets.core.html#var-subset-intro-thm">subset-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-subset-intro-thm"><h3>subset-intro-thm</h3><div class="usage"><code>(subset-intro-thm [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (forall [x T] (==&gt; (elem x s1) (elem x s2))) (subset s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for subset relation.</p></div></div></div><div class="public anchor" id="var-subset-prop"><h3>subset-prop</h3><div class="usage"><code>(subset-prop [T :type] [P (==&gt; T :type)] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall [x T] (==&gt; (elem x s2) (P x)))
 (subset s1 s2)
 (forall [x T] (==&gt; (elem x s1) (P x))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on subsets.</p></div></div></div><div class="public anchor" id="var-subset-refl"><h3>subset-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subset-refl s)</code></p>
<p>The subset relation is reflexive, cf. <a href="latte-sets.core.html#var-subset-refl-thm">subset-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-subset-refl-thm"><h3>subset-refl-thm</h3><div class="usage"><code>(subset-refl-thm [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset s s)
</code></pre>
<p><strong>Theorem</strong>: The subset relation is reflexive.</p></div></div></div><div class="public anchor" id="var-subset-trans"><h3>subset-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subset-trans s1 s2 s3)</code></p>
<p>The subset relation is transitive, cf. <a href="latte-sets.core.html#var-subset-trans-thm">subset-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-subset-trans-thm"><h3>subset-trans-thm</h3><div class="usage"><code>(subset-trans-thm [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subset s1 s2) (subset s2 s3) (subset s1 s3))
</code></pre>
<p><strong>Theorem</strong>: The subset relation is transitive.</p></div></div></div></div></body></html>