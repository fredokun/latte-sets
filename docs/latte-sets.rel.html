<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.rel documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b4-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2 current"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.rel.html#var-dom"><div class="inner"><span>dom</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-dom-def"><div class="inner"><span>dom-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel"><div class="inner"><span>emptyrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel-prop"><div class="inner"><span>emptyrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-equivalence"><div class="inner"><span>equivalence</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-equivalence-def"><div class="inner"><span>equivalence-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fetch-rel-type"><div class="inner"><span>fetch-rel-type</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel"><div class="inner"><span>fullrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel-prop"><div class="inner"><span>fullrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-equiv"><div class="inner"><span>ident-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-refl"><div class="inner"><span>ident-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-sym"><div class="inner"><span>ident-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-trans"><div class="inner"><span>ident-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-identity"><div class="inner"><span>identity</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-prod"><div class="inner"><span>prod</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-prod-def"><div class="inner"><span>prod-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel"><div class="inner"><span>psubrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antirefl"><div class="inner"><span>psubrel-antirefl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antirefl-thm"><div class="inner"><span>psubrel-antirefl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antisym"><div class="inner"><span>psubrel-antisym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antisym-thm"><div class="inner"><span>psubrel-antisym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-def"><div class="inner"><span>psubrel-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel"><div class="inner"><span>psubrel-emptyrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel-conv"><div class="inner"><span>psubrel-emptyrel-conv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel-equiv"><div class="inner"><span>psubrel-emptyrel-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-trans"><div class="inner"><span>psubrel-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-trans-thm"><div class="inner"><span>psubrel-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ran"><div class="inner"><span>ran</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ran-def"><div class="inner"><span>ran-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp"><div class="inner"><span>rcomp</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc"><div class="inner"><span>rcomp-assoc</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc-subrel"><div class="inner"><span>rcomp-assoc-subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc-suprel"><div class="inner"><span>rcomp-assoc-suprel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc-thm"><div class="inner"><span>rcomp-assoc-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-def"><div class="inner"><span>rcomp-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-reflexive"><div class="inner"><span>reflexive</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-reflexive-def"><div class="inner"><span>reflexive-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel"><div class="inner"><span>rel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal"><div class="inner"><span>rel-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-releq"><div class="inner"><span>rel-equal-implies-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-subrel"><div class="inner"><span>rel-equal-implies-subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-prop"><div class="inner"><span>rel-equal-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-refl"><div class="inner"><span>rel-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-refl-thm"><div class="inner"><span>rel-equal-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-releq"><div class="inner"><span>rel-equal-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-sym"><div class="inner"><span>rel-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-sym-thm"><div class="inner"><span>rel-equal-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-trans"><div class="inner"><span>rel-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-trans-thm"><div class="inner"><span>rel-equal-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equality"><div class="inner"><span>rel-equality</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq"><div class="inner"><span>releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-def"><div class="inner"><span>releq-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-implies-rel-equal-ax"><div class="inner"><span>releq-implies-rel-equal-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-refl"><div class="inner"><span>releq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-refl-thm"><div class="inner"><span>releq-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-sym"><div class="inner"><span>releq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-sym-thm"><div class="inner"><span>releq-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-trans"><div class="inner"><span>releq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-trans-thm"><div class="inner"><span>releq-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel"><div class="inner"><span>subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-def"><div class="inner"><span>subrel-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-emptyrel-lower-bound"><div class="inner"><span>subrel-emptyrel-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-fullrel-upper-bound"><div class="inner"><span>subrel-fullrel-upper-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-prop"><div class="inner"><span>subrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-refl"><div class="inner"><span>subrel-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-refl-thm"><div class="inner"><span>subrel-refl-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-trans"><div class="inner"><span>subrel-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-trans-thm"><div class="inner"><span>subrel-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symmetric"><div class="inner"><span>symmetric</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symmetric-def"><div class="inner"><span>symmetric-def</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-transitive"><div class="inner"><span>transitive</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-transitive-def"><div class="inner"><span>transitive-def</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.rel</h1><div class="doc"><div class="markdown"><p>A <strong>relation</strong> from elements of a given type <code>T</code> to elements of <code>U</code> is formalized with type <code>(==&gt; T U :type)</code>.</p>
<p>This namespace provides some important properties about such  relations.</p></div></div><div class="public anchor" id="var-dom"><h3>dom</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(dom R)</code></p>
<p><code>(dom R)</code> is the domain of relation <code>R</code>, cf. <a href="latte-sets.rel.html#var-dom-def">dom-def</a>.</p></div></div></div><div class="public anchor" id="var-dom-def"><h3>dom-def</h3><div class="usage"><code>(dom-def [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (exists [y U] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The domain of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-emptyrel"><h3>emptyrel</h3><div class="usage"><code>(emptyrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/absurd))
</code></pre>
<p><strong>Definition</strong>: The empty relation.</p></div></div></div><div class="public anchor" id="var-emptyrel-prop"><h3>emptyrel-prop</h3><div class="usage"><code>(emptyrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (not ((emptyrel T U) x y))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-equivalence"><h3>equivalence</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(equivalence R)</code></p>
<p><code>(equivalence R)</code> holds if <code>R</code> is an equivalence relation, cf. <a href="latte-sets.rel.html#var-equivalence-def">equivalence-def</a>.</p></div></div></div><div class="public anchor" id="var-equivalence-def"><h3>equivalence-def</h3><div class="usage"><code>(equivalence-def [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (reflexive R) (and (symmetric R) (transitive R)))
</code></pre>
<p><strong>Definition</strong>: An equivalence relation.</p></div></div></div><div class="public anchor" id="var-fetch-rel-type"><h3>fetch-rel-type</h3><div class="usage"><code>(fetch-rel-type def-env ctx r-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fullrel"><h3>fullrel</h3><div class="usage"><code>(fullrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/truth))
</code></pre>
<p><strong>Definition</strong>: The full (total) relation between <code>T</code> and <code>U</code>.</p></div></div></div><div class="public anchor" id="var-fullrel-prop"><h3>fullrel-prop</h3><div class="usage"><code>(fullrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] ((fullrel T U) x y)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-equiv"><h3>ident-equiv</h3><div class="usage"><code>(ident-equiv [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(equivalence (identity T))
</code></pre>
<p><strong>Theorem</strong>: The indentity on <code>T</code> is an equivalence relation.</p></div></div></div><div class="public anchor" id="var-ident-refl"><h3>ident-refl</h3><div class="usage"><code>(ident-refl [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(reflexive (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-sym"><h3>ident-sym</h3><div class="usage"><code>(ident-sym [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(symmetric (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-trans"><h3>ident-trans</h3><div class="usage"><code>(ident-trans [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(transitive (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-identity"><h3>identity</h3><div class="usage"><code>(identity [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x y T] (equal x y))
</code></pre>
<p><strong>Definition</strong>: The indentity relation on <code>T</code>.</p></div></div></div><div class="public anchor" id="var-prod"><h3>prod</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(prod s1 s2)</code></p>
<p><code>(prod s1 s2)</code> is the cartersian product of <code>s1</code> and <code>s2</code> i.e. <code>s1</code>⨯<code>s2</code>, cf. <a href="latte-sets.rel.html#var-prod-def">prod-def</a>.</p></div></div></div><div class="public anchor" id="var-prod-def"><h3>prod-def</h3><div class="usage"><code>(prod-def [T :type] [U :type] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] (and (elem x s1) (elem y s2))))
</code></pre>
<p><strong>Definition</strong>: The cartersian product of sets <code>s1</code> and <code>s2</code>, i.e. <code>s1</code>⨯<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-psubrel"><h3>psubrel</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubrel R1 R2)</code></p>
<p><code>(psubrel R1 R2)</code> means <code>R1</code> si a sub-relation of <code>R2</code>, cf. <a href="latte-sets.rel.html#var-psubrel-def">psubrel-def</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-antirefl"><h3>psubrel-antirefl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubrel-antirefl R)</code></p>
<p><code>(psubrel-antirefl R)</code> means proper sub-relation is antireflexive, cf. <a href="latte-sets.rel.html#var-psubrel-antirefl-thm">psubrel-antirefl-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-antirefl-thm"><h3>psubrel-antirefl-thm</h3><div class="usage"><code>(psubrel-antirefl-thm [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (psubrel R R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-antisym"><h3>psubrel-antisym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubrel-antisym R1 R2)</code></p>
<p><code>(psubrel-antisym R1 R2)</code> means proper sub-relation is antisymmetric, cf. <a href="null">psubrem-antisym-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-antisym-thm"><h3>psubrel-antisym-thm</h3><div class="usage"><code>(psubrel-antisym-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (and (psubrel R1 R2) (psubrel R2 R1)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-def"><h3>psubrel-def</h3><div class="usage"><code>(psubrel-def [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subrel R1 R2) (not (releq R1 R2)))
</code></pre>
<p><strong>Definition</strong>: The anti-reflexive variant of <a href="latte-sets.rel.html#var-subrel">subrel</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel"><h3>psubrel-emptyrel</h3><div class="usage"><code>(psubrel-emptyrel [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubrel (emptyrel T U) R) (not (releq R (emptyrel T U))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel-conv"><h3>psubrel-emptyrel-conv</h3><div class="usage"><code>(psubrel-emptyrel-conv [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (not (releq R (emptyrel T U))) (psubrel (emptyrel T U) R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel-equiv"><h3>psubrel-emptyrel-equiv</h3><div class="usage"><code>(psubrel-emptyrel-equiv [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (psubrel (emptyrel T U) R) (not (releq R (emptyrel T U))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-trans"><h3>psubrel-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(psubrel-trans R1 R2 R3)</code></p>
<p><code>(psubrel-trans R1 R2 R3)</code> means proper sub-relation is transitive, cf. <a href="latte-sets.rel.html#var-psubrel-trans-thm">psubrel-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-trans-thm"><h3>psubrel-trans-thm</h3><div class="usage"><code>(psubrel-trans-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubrel R1 R2) (psubrel R2 R3) (psubrel R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ran"><h3>ran</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(ran R)</code></p>
<p><code>(ran R)</code> is the range (or codomain) of relation <code>R</code>, cf. <a href="latte-sets.rel.html#var-ran-def">ran-def</a>.</p></div></div></div><div class="public anchor" id="var-ran-def"><h3>ran-def</h3><div class="usage"><code>(ran-def [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [y U] (exists [x T] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The range of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-rcomp"><h3>rcomp</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rcomp R1 R2)</code></p>
<p><code>(rcomp R1 R2)</code> is the relational composition of <code>R1</code> and <code>R2</code>, cf. <a href="latte-sets.rel.html#var-rcomp-def">rcomp-def</a>.</p></div></div></div><div class="public anchor" id="var-rcomp-assoc"><h3>rcomp-assoc</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rcomp-assoc R1 R2 R3)</code></p>
<p><code>(rcomp-assoc R1 R2 R3)</code>. Relational composition is associative, cf. <a href="null">recomp-assoc-thm</a>.</p></div></div></div><div class="public anchor" id="var-rcomp-assoc-subrel"><h3>rcomp-assoc-subrel</h3><div class="usage"><code>(rcomp-assoc-subrel [T :type] [U :type] [V :type] [W :type] [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (rcomp R1 (rcomp R2 R3)) (rcomp (rcomp R1 R2) R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rcomp-assoc-suprel"><h3>rcomp-assoc-suprel</h3><div class="usage"><code>(rcomp-assoc-suprel [T :type] [U :type] [V :type] [W :type] [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (rcomp (rcomp R1 R2) R3) (rcomp R1 (rcomp R2 R3)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rcomp-assoc-thm"><h3>rcomp-assoc-thm</h3><div class="usage"><code>(rcomp-assoc-thm [T :type] [U :type] [V :type] [W :type] [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(releq (rcomp R1 (rcomp R2 R3)) (rcomp (rcomp R1 R2) R3))
</code></pre>
<p><strong>Theorem</strong>: Relational composition is associative.</p></div></div></div><div class="public anchor" id="var-rcomp-def"><h3>rcomp-def</h3><div class="usage"><code>(rcomp-def [T :type] [U :type] [V :type] [R1 (rel T U)] [R2 (rel U V)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [z V] (exists [y U] (and (R1 x y) (R2 y z)))))
</code></pre>
<p><strong>Definition</strong>: Sequential relational composition.</p></div></div></div><div class="public anchor" id="var-reflexive"><h3>reflexive</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(reflexive R)</code></p>
<p><code>(reflexive R)</code> holds if <code>R</code> is reflexive, cf. <a href="latte-sets.rel.html#var-reflexive-def">reflexive-def</a>.</p></div></div></div><div class="public anchor" id="var-reflexive-def"><h3>reflexive-def</h3><div class="usage"><code>(reflexive-def [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (R x x))
</code></pre>
<p><strong>Definition</strong>: A reflexive relation.</p></div></div></div><div class="public anchor" id="var-rel"><h3>rel</h3><div class="usage"><code>(rel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T U :type)
</code></pre>
<p><strong>Definition</strong>: The type of relations.</p></div></div></div><div class="public anchor" id="var-rel-equal"><h3>rel-equal</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rel-equal R1 R2)</code></p>
<p><code>(rel-equal R1 R2) means</code>R1<code>and</code>R2` are equal in the sense of <em>Leibniz</em>, cf. <a href="latte-sets.rel.html#var-rel-equality">rel-equality</a>.</p></div></div></div><div class="public anchor" id="var-rel-equal-implies-releq"><h3>rel-equal-implies-releq</h3><div class="usage"><code>(rel-equal-implies-releq [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (releq R1 R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-implies-subrel"><h3>rel-equal-implies-subrel</h3><div class="usage"><code>(rel-equal-implies-subrel [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (subrel R1 R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-prop"><h3>rel-equal-prop</h3><div class="usage"><code>(rel-equal-prop [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [P (==&gt; (rel T U) :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (P R1) (P R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-refl"><h3>rel-equal-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rel-equal-refl R)</code></p>
<p><code>(rel-equal-refl R)</code> <code>rel-equal</code> is reflexive, cf. <a href="latte-sets.rel.html#var-rel-equal-refl-thm">rel-equal-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-rel-equal-refl-thm"><h3>rel-equal-refl-thm</h3><div class="usage"><code>(rel-equal-refl-thm [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(rel-equal R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-releq"><h3>rel-equal-releq</h3><div class="usage"><code>(rel-equal-releq [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (rel-equal R1 R2) (releq R1 R2))
</code></pre>
<p><strong>Theorem</strong>: Coincidence of <em>Leibniz</em>-style and subset-based equality for relations.</p></div></div></div><div class="public anchor" id="var-rel-equal-sym"><h3>rel-equal-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rel-equal-sym R1 R2)</code></p>
<p><code>(rel-equal-sym R1 R2)</code> <code>rel-equal</code> is symmetric, cf. <a href="latte-sets.rel.html#var-rel-equal-sym-thm">rel-equal-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-rel-equal-sym-thm"><h3>rel-equal-sym-thm</h3><div class="usage"><code>(rel-equal-sym-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (rel-equal R2 R1))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-trans"><h3>rel-equal-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(rel-equal-trans R1 R2 R3)</code></p>
<p><code>(rel-equal-trans R1 R2 R3)</code> <code>rel-equal</code> is transitive, cf. <a href="latte-sets.rel.html#var-rel-equal-trans-thm">rel-equal-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-rel-equal-trans-thm"><h3>rel-equal-trans-thm</h3><div class="usage"><code>(rel-equal-trans-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (rel-equal R2 R3) (rel-equal R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equality"><h3>rel-equality</h3><div class="usage"><code>(rel-equality [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (rel T U) :type)] (&lt;=&gt; (P R1) (P R2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-stype equality for relations.</p>
<p>It says that two relations <code>R1</code> and <code>R2</code> are equal iff for any predicate <code>P</code> then <code>(P R1)</code> if and only if <code>(P R2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.core.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-releq"><h3>releq</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(releq R1 R2)</code></p>
<p><code>(releq R1 R2)</code> means relations <code>R1</code> and <code>R2</code> are equal wrt. the <a href="latte-sets.rel.html#var-subrel">subrel</a> ordering,  cf. <a href="latte-sets.rel.html#var-releq-def">releq-def</a>.</p></div></div></div><div class="public anchor" id="var-releq-def"><h3>releq-def</h3><div class="usage"><code>(releq-def [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subrel R1 R2) (subrel R2 R1))
</code></pre>
<p><strong>Definition</strong>: Subset-based equality on relations.</p></div></div></div><div class="public anchor" id="var-releq-implies-rel-equal-ax"><h3>releq-implies-rel-equal-ax</h3><div class="usage"><code>(releq-implies-rel-equal-ax [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (rel-equal R1 R2))
</code></pre>
<p><strong>Axiom</strong>: As for the set case (cf. <a href="null">sets/seteq-implies-set-equal-ax</a>), going from the subset-based equality to the (thus more general) <em>leibniz</em>-style one requires an axiom.</p></div></div></div><div class="public anchor" id="var-releq-refl"><h3>releq-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(releq-refl R)</code></p>
<p><code>(releq-refl R)</code> <code>releq</code> is reflexive, cf. <a href="latte-sets.rel.html#var-releq-refl-thm">releq-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-releq-refl-thm"><h3>releq-refl-thm</h3><div class="usage"><code>(releq-refl-thm [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(releq R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-releq-sym"><h3>releq-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(releq-sym R1 R2)</code></p>
<p><code>(releq-sym R1 R2)</code> <code>releq</code> is symmetric, cf. <a href="latte-sets.rel.html#var-releq-sym-thm">releq-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-releq-sym-thm"><h3>releq-sym-thm</h3><div class="usage"><code>(releq-sym-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (releq R2 R1))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-releq-trans"><h3>releq-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(releq-trans R1 R2 R3)</code></p>
<p><code>(releq-trans R1 R2 R3)</code> <code>releq</code> is transitive, cf. <a href="latte-sets.rel.html#var-releq-trans-thm">releq-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-releq-trans-thm"><h3>releq-trans-thm</h3><div class="usage"><code>(releq-trans-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (releq R2 R3) (releq R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-subrel"><h3>subrel</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subrel R1 R2)</code></p>
<p>The subset ordering for relations, <code>(subrel R1 R2)</code> is <code>R1</code>⊆<code>R2</code>, cf. <a href="latte-sets.rel.html#var-subrel-def">subrel-def</a>.</p></div></div></div><div class="public anchor" id="var-subrel-def"><h3>subrel-def</h3><div class="usage"><code>(subrel-def [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (==&gt; (R1 x y) (R2 x y))))
</code></pre>
<p><strong>Definition</strong>: The subset ordering for relations.</p></div></div></div><div class="public anchor" id="var-subrel-emptyrel-lower-bound"><h3>subrel-emptyrel-lower-bound</h3><div class="usage"><code>(subrel-emptyrel-lower-bound [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (emptyrel T U) R)
</code></pre>
<p><strong>Theorem</strong>: The empty relation is a subset of every other relations.</p></div></div></div><div class="public anchor" id="var-subrel-fullrel-upper-bound"><h3>subrel-fullrel-upper-bound</h3><div class="usage"><code>(subrel-fullrel-upper-bound [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R (fullrel T U))
</code></pre>
<p><strong>Theorem</strong>: The full relation is a superset of every other relations.</p></div></div></div><div class="public anchor" id="var-subrel-prop"><h3>subrel-prop</h3><div class="usage"><code>(subrel-prop [T :type] [U :type] [P (==&gt; T U :type)] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall [x T] (forall [y U] (==&gt; (R2 x y) (P x y))))
 (subrel R1 R2)
 (forall [x T] (forall [y U] (==&gt; (R1 x y) (P x y)))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on relational subsets.</p></div></div></div><div class="public anchor" id="var-subrel-refl"><h3>subrel-refl</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subrel-refl R)</code></p>
<p><code>(subrel-refl R)</code> Reflexivity of <code>subrel</code>, cf. <a href="latte-sets.rel.html#var-subrel-refl-thm">subrel-refl-thm</a>.</p></div></div></div><div class="public anchor" id="var-subrel-refl-thm"><h3>subrel-refl-thm</h3><div class="usage"><code>(subrel-refl-thm [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-subrel-trans"><h3>subrel-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(subrel-trans R1 R2 R3)</code></p>
<p><code>(subrel-trans R1 R2 R3)</code> Transitivity of <code>subrel</code>, cf. <a href="latte-sets.rel.html#var-subrel-trans-thm">subrel-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-subrel-trans-thm"><h3>subrel-trans-thm</h3><div class="usage"><code>(subrel-trans-thm [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subrel R1 R2) (subrel R2 R3) (subrel R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-symmetric"><h3>symmetric</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(symmetric R)</code></p>
<p><code>(symmetric R)</code> holds if <code>R</code> is symmetric, cf. <a href="latte-sets.rel.html#var-reflexive-def">reflexive-def</a>.</p></div></div></div><div class="public anchor" id="var-symmetric-def"><h3>symmetric-def</h3><div class="usage"><code>(symmetric-def [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y T] (==&gt; (R x y) (R y x)))
</code></pre>
<p><strong>Definition</strong>: A symmetric relation.</p></div></div></div><div class="public anchor" id="var-transitive"><h3>transitive</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(transitive R)</code></p>
<p><code>(transitive R)</code> holds if <code>R</code> is transitive, cf. <a href="latte-sets.rel.html#var-transitive-def">transitive-def</a>.</p></div></div></div><div class="public anchor" id="var-transitive-def"><h3>transitive-def</h3><div class="usage"><code>(transitive-def [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y z T] (==&gt; (R x y) (R y z) (R x z)))
</code></pre>
<p><strong>Definition</strong>: A transitive relation.</p></div></div></div></div></body></html>